<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>태양계정복 — 앱 다운로드</title>
<meta name="description" content="태양계정복 APK 다운로드 페이지 — /apks 폴더에 업로드된 APK들을 자동으로 표시합니다." />
<style>
  :root{--bg:#05060a;--card:#0b1220;--accent:#00aaff;--muted:#99a6b8;--glass: rgba(255,255,255,0.03);}
  html,body{height:100%;margin:0;font-family:Inter, "Noto Sans KR", Arial, sans-serif;background:linear-gradient(180deg,#02030a 0%, #071026 100%);color:#e9f6ff}
  .wrap{max-width:980px;margin:28px auto;padding:20px;}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:18px}
  h1{font-size:20px;margin:0;color:#dffaff}
  p.lead{margin:6px 0 0;color:var(--muted);font-size:13px}
  .controls{display:flex;gap:8px;align-items:center}
  button, .btn {cursor:pointer;border:0;padding:8px 12px;border-radius:8px;font-weight:700}
  .btn.primary{background:var(--accent);color:#001220;box-shadow:0 6px 18px rgba(0,160,255,0.07)}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#e8faff}
  .card{background:linear-gradient(180deg,var(--card), #071022);padding:14px;border-radius:12px;box-shadow:0 10px 30px rgba(2,6,20,0.6)}
  .list{margin-top:14px;display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px}
  .apk-item{background:var(--glass);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02);display:flex;flex-direction:column;gap:8px}
  .apk-top{display:flex;align-items:center;justify-content:space-between;gap:10px}
  .apk-meta{font-size:13px;color:var(--muted)}
  .apk-name{font-weight:800;color:#fff}
  .apk-actions{display:flex;gap:8px;align-items:center}
  .small{font-size:12px;color:var(--muted)}
  .empty{padding:28px;text-align:center;color:var(--muted)}
  .hint{margin-top:12px;font-size:13px;color:var(--muted);}
  footer{margin-top:18px;text-align:center;color:var(--muted);font-size:13px}
  /* responsive */
  @media (max-width:520px){ .controls{flex-direction:column;align-items:flex-end} header{align-items:flex-start;gap:8px} }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>태양계정복 — 앱 다운로드</h1>
        <p class="lead">/apks 폴더에 업로드한 APK들을 자동으로 표시합니다. 파일명 규칙: <code>태양계정복-ver0.1.apk</code> (예)</p>
      </div>
      <div class="controls">
        <button id="refreshBtn" class="btn ghost">새로고침</button>
        <button id="backBtn" class="btn primary">게임으로 돌아가기</button>
      </div>
    </header>

    <section class="card" aria-live="polite">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:12px">
        <strong>사용 가능한 APK</strong>
        <span class="small" id="countText">로딩 중…</span>
      </div>

      <div id="list" class="list" style="min-height:120px">
        <div class="empty">파일을 불러오는 중입니다…</div>
      </div>

      <div class="hint">
        서버에서 디렉터리 목록을 제공하지 않으면 자동 탐지가 실패할 수 있습니다. (이 경우 `apks/index.json`을 업로드하거나 서버 설정에서 디렉터리 리스팅을 활성화하세요.)<br>
        <strong>index.json 예시</strong> (apks/index.json):
        <pre style="background:#021124;padding:8px;border-radius:6px;color:#bfefff">[
  {"filename":"태양계정복-ver0.1.apk","updated":"2025-09-20T12:34:56Z","size":23456789},
  {"filename":"태양계정복-ver0.2.apk","updated":"2025-10-01T08:00:00Z","size":24567890}
]</pre>
      </div>
    </section>

    <footer>
      업로드할 APK는 <code>/apks/</code> 폴더에 넣어주세요. 파일명 규칙(예): <code>태양계정복-ver0.1.apk</code>
    </footer>
  </div>

<script>
(async function(){
  const listEl = document.getElementById('list');
  const countText = document.getElementById('countText');
  const refreshBtn = document.getElementById('refreshBtn');
  const backBtn = document.getElementById('backBtn');

  refreshBtn.addEventListener('click', ()=> loadList(true));
  backBtn.addEventListener('click', closeToGame);

  // helper: human readable size
  function formatBytes(bytes){
    if (!bytes && bytes !== 0) return '';
    const thresh = 1024;
    if (Math.abs(bytes) < thresh) return bytes + ' B';
    const units = ['KB','MB','GB','TB'];
    let u = -1;
    do { bytes /= thresh; ++u; } while(Math.abs(bytes) >= thresh && u < units.length-1);
    return bytes.toFixed(1) + ' ' + units[u];
  }

  // extract version from filename, fallback to cleaned name
  function extractVersion(filename){
    // common patterns: ver0.1, ver-0.1, v0.1, _0.1
    const name = filename.replace(/\.apk$/i,'');
    const m1 = name.match(/ver[-_]?(\d+(?:\.\d+)*)/i);
    if (m1) return 'v' + m1[1];
    const m2 = name.match(/\bv(\d+(?:\.\d+)*)\b/i);
    if (m2) return 'v' + m2[1];
    const m3 = name.match(/(\d+(?:\.\d+){0,})/);
    if (m3) return 'v' + m3[1];
    // otherwise friendly name by removing prefix
    return name;
  }

  // compare semantic-ish versions (v1.2.3)
  function compareVersions(a,b){
    if (!a && !b) return 0;
    if (!a) return 1;
    if (!b) return -1;
    const pa = a.replace(/^v/i,'').split('.').map(n=>parseInt(n)||0);
    const pb = b.replace(/^v/i,'').split('.').map(n=>parseInt(n)||0);
    const len = Math.max(pa.length,pb.length);
    for(let i=0;i<len;i++){
      const na = pa[i]||0;
      const nb = pb[i]||0;
      if (na !== nb) return nb - na; // descending
    }
    return 0;
  }

  // attempt to fetch HEAD for metadata (size/last-modified)
  async function headInfo(path){
    try{
      const resp = await fetch(path, { method:'HEAD' });
      if (!resp.ok) return null;
      const size = resp.headers.get('content-length');
      const lm = resp.headers.get('last-modified');
      return { size: size ? parseInt(size,10) : null, updated: lm ? new Date(lm).toISOString() : null };
    }catch(e){
      return null;
    }
  }

  // parse directory listing HTML to extract .apk hrefs
  function parseDirectoryListing(html, base='/apks/'){
    const hrefs = [];
    try{
      const doc = new DOMParser().parseFromString(html,'text/html');
      const anchors = doc.querySelectorAll('a[href]');
      anchors.forEach(a => {
        const href = a.getAttribute('href');
        if (!href) return;
        // allow relative and absolute that point to .apk
        if (/\.apk($|\?)/i.test(href)){
          // normalize to just filename if in same folder
          let fn = href.split('?')[0].split('#')[0];
          // strip leading path
          fn = fn.replace(/^.*\/([^\/]+)$/, '$1');
          if (fn && /\.apk$/i.test(fn)) hrefs.push(fn);
        }
      });
      // dedupe
      return [...new Set(hrefs)];
    }catch(e){
      return [];
    }
  }

  async function loadList(forceIndex=false){
    listEl.innerHTML = '<div class="empty">파일을 불러오는 중입니다…</div>';
    countText.textContent = '로딩…';

    // 1) 우선 apks/index.json 시도
    if (!forceIndex) {
      try {
        const idxResp = await fetch('/apks/index.json', {cache:'no-store'});
        if (idxResp.ok){
          const j = await idxResp.json();
          if (Array.isArray(j) && j.length>0){
            // normalize items
            const items = j.map(it => ({
              filename: String(it.filename || it.name || '').trim(),
              size: it.size ? Number(it.size) : (it.size === 0 ? 0 : null),
              updated: it.updated || it.lastModified || null
            })).filter(i=>i.filename && /\.apk$/i.test(i.filename));
            if (items.length) {
              return renderItems(items);
            }
          }
        }
      } catch(e){
        // ignore and fallthrough to listing parse
      }
    }

    // 2) fallback: fetch /apks/ HTML and parse <a href>
    try{
      const resp = await fetch('/apks/', {cache:'no-store'});
      if (!resp.ok) throw new Error('no dir listing');
      const html = await resp.text();
      const filenames = parseDirectoryListing(html, '/apks/');
      if (filenames.length === 0) throw new Error('no links found');
      // try to gather HEAD info for each file (best-effort)
      const itemPromises = filenames.map(async fn => {
        const meta = await headInfo('/apks/' + encodeURIComponent(fn));
        return { filename: fn, size: meta && meta.size ? meta.size : null, updated: meta && meta.updated ? meta.updated : null };
      });
      const items = await Promise.all(itemPromises);
      return renderItems(items);
    }catch(err){
      // 3) 최종 실패 — 안내 표시
      listEl.innerHTML = `<div class="empty">APK 목록을 불러오지 못했습니다.<br><br>서버에서 디렉터리 리스팅이 비활성화되어 있거나 <code>/apks/index.json</code>이 없습니다.<br>관리자(당신)가 <code>/apks/index.json</code>을 업로드하거나 서버 설정에서 디렉터리 목록을 허용해 주세요.</div>`;
      countText.textContent = '목록 없음';
      return;
    }
  }

  function renderItems(items){
    // normalize (ensure filename)
    const normalized = items
      .filter(it => it && it.filename)
      .map(it => {
        const fn = it.filename;
        const ver = extractVersion(fn);
        return { filename: fn, version: ver, size: it.size || null, updated: it.updated || null };
      });

    // sort: version desc, then updated desc
    normalized.sort((a,b) => {
      const cv = compareVersions(a.version,b.version);
      if (cv !== 0) return cv;
      const da = a.updated ? new Date(a.updated).getTime() : 0;
      const db = b.updated ? new Date(b.updated).getTime() : 0;
      return db - da;
    });

    // render
    if (!normalized.length){
      listEl.innerHTML = '<div class="empty">표시할 APK가 없습니다.</div>';
      countText.textContent = '0개';
      return;
    }
    countText.textContent = `${normalized.length}개`;
    listEl.innerHTML = '';
    normalized.forEach(it => {
      const item = document.createElement('div');
      item.className = 'apk-item';
      const prettyName = `태양계정복 ${it.version || ''}`.trim();
      const info = [];
      if (it.updated) info.push(new Date(it.updated).toLocaleString());
      if (it.size != null) info.push(formatBytes(it.size));
      const infoText = info.join(' · ');
      item.innerHTML = `
        <div class="apk-top">
          <div>
            <div class="apk-name">${prettyName}</div>
            <div class="apk-meta">${it.filename}</div>
          </div>
          <div style="text-align:right">
            <div class="small">${infoText}</div>
          </div>
        </div>
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="apk-actions">
            <a class="btn ghost" role="link" href="/apks/${encodeURIComponent(it.filename)}" download>다운로드</a>
            <button class="btn ghost" type="button" data-fn="${it.filename}" onclick="window.open('/apks/${encodeURIComponent(it.filename)}','_blank')">새 탭으로 열기</button>
          </div>
          <div class="small">버전: <strong style="color:#fff;margin-left:6px">${it.version}</strong></div>
        </div>
      `;
      listEl.appendChild(item);
    });
  }

  // initial load
  await loadList();

  // expose loadList to global for refresh via console if needed
  window.reloadApkList = () => loadList(true);

  // close/popup logic similar to main page
  function closeToGame(){
    try {
      if (window.opener && !window.opener.closed) {
        try { window.opener.focus(); } catch(e){}
        try { window.opener.postMessage && window.opener.postMessage({ type:'request-close-popup', from: location.href }, '*'); } catch(e){}
      }
    } catch(e){}
    try { window.close(); } catch(e){}
    setTimeout(() => {
      try {
        if (!window.closed) window.location.href = '/index.html';
      } catch (e) {
        try { window.open('/index.html','_self'); } catch(e) {}
      }
    }, 220);
  }

})();
</script>
</body>
</html>
