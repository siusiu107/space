<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ğŸ„ Christmas Rhythm Stage</title>
  <style>
    body{ margin:0; font-family:'Noto Sans KR', system-ui, -apple-system, sans-serif; background:radial-gradient(circle at 20% 20%, rgba(255,255,255,0.08), transparent 30%), #0a0f1c; color:#e7f5ff; }
    .layout{ display:flex; flex-wrap:wrap; gap:14px; padding:14px; max-width:1200px; margin:0 auto; }
    .panel{ flex:1 1 320px; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.1); border-radius:12px; padding:12px; box-shadow:0 10px 28px rgba(0,0,0,0.45); }
    #game-container{ flex:2 1 520px; min-height:640px; background:#050912; border:1px solid rgba(255,255,255,0.08); border-radius:12px; position:relative; overflow:hidden; }
    h1{ margin:0 0 6px; font-size:20px; }
    .hint{ color:#bcd8ff; font-size:14px; line-height:1.55; }
    select, button{ width:100%; padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,0.18); background:rgba(0,0,0,0.25); color:#fff; font-size:14px; }
    button{ cursor:pointer; background:linear-gradient(90deg,#0de3ff,#4a7cff); color:#001218; font-weight:800; border:none; box-shadow:0 8px 18px rgba(0,180,255,0.22); }
    button:disabled{ opacity:.6; cursor:not-allowed; box-shadow:none; }
    .stats{ display:flex; flex-wrap:wrap; gap:10px; margin-top:10px; font-size:14px; }
    .stat{ flex:1 1 120px; padding:8px 10px; border-radius:10px; background:rgba(0,0,0,0.25); border:1px solid rgba(255,255,255,0.08); }
    #status{ margin-top:8px; color:#ffe8a6; font-weight:700; min-height:20px; }
    .keys{ margin-top:10px; display:flex; gap:8px; flex-wrap:wrap; }
    .keycap{ flex:1 1 60px; padding:8px; text-align:center; border-radius:10px; background:rgba(255,255,255,0.07); border:1px solid rgba(255,255,255,0.08); }
    canvas{ border-radius:12px; overflow:hidden; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>
  <div class="layout">
    <div class="panel">
      <h1>ğŸ§ í¬ë¦¬ìŠ¤ë§ˆìŠ¤ ë¦¬ë“¬ê²Œì„</h1>
      <p class="hint">ì €ì‘ê¶Œ ì—†ëŠ” í¬ë¦¬ìŠ¤ë§ˆìŠ¤/ì—°ë§ í…Œë§ˆ ìŒì•… 10ê³¡ì„ ê³¨ë¼ í”Œë ˆì´í•˜ì„¸ìš”. ê³¡ì„ í•œ ë²ˆë„ í‹€ë¦¬ì§€ ì•Šìœ¼ë©´ ì‚°íƒ€ ì¡°ê° 5ê°œë¥¼ íšë“í•´ìš”!</p>
      <label style="display:block; margin-top:10px; font-weight:700;">ê³¡ ì„ íƒ</label>
      <select id="track-select" aria-label="í¬ë¦¬ìŠ¤ë§ˆìŠ¤ ê³¡ ì„ íƒ"></select>
      <button id="start-btn" style="margin-top:10px;">ê²Œì„ ì‹œì‘</button>
      <div id="status" aria-live="polite"></div>
      <div class="stats">
        <div class="stat">íˆíŠ¸: <span id="hit-count">0</span></div>
        <div class="stat">ë¯¸ìŠ¤: <span id="miss-count">0</span></div>
        <div class="stat">ì—°ì†: <span id="combo-count">0</span></div>
      </div>
      <div class="keys">
        <div class="keycap">D</div>
        <div class="keycap">F</div>
        <div class="keycap">J</div>
        <div class="keycap">K</div>
      </div>
    </div>
    <div id="game-container" aria-label="ë¦¬ë“¬ê²Œì„ ì˜ì—­"></div>
  </div>

  <script>
    const tracks = Array.from({ length: 10 }, (_, i) => ({ name: `Holiday Groove ${i + 1}`, seed: i + 1 }));

    const keyToLane = { KeyD:0, KeyF:1, KeyJ:2, KeyK:3 };
    const laneColors = ['#00d4ff','#5cffc8','#ffc85c','#ff7aa5'];
    let gameInstance = null;
    let currentScene = null;
    let activeAudio = null;
    const generatedUrls = new Map();

    const rhythmData = { schedule: [], startedAt: 0, hits:0, misses:0, combo:0, sent:false };

    const statusEl = document.getElementById('status');
    const hitEl = document.getElementById('hit-count');
    const missEl = document.getElementById('miss-count');
    const comboEl = document.getElementById('combo-count');
    const startBtn = document.getElementById('start-btn');
    const selectEl = document.getElementById('track-select');

    function fillTracks(){
      tracks.forEach((t, idx) => {
        const opt = document.createElement('option');
        opt.value = idx;
        opt.textContent = `${idx+1}. ${t.name}`;
        selectEl.appendChild(opt);
      });
    }

    function updateStats(){
      hitEl.textContent = rhythmData.hits;
      missEl.textContent = rhythmData.misses;
      comboEl.textContent = rhythmData.combo;
    }

    function buildSchedule(durationMs){
      const beat = 680;
      const count = Math.min(180, Math.max(40, Math.floor(durationMs / beat)));
      const schedule = [];
      let lane = 0;
      for (let i=0;i<count;i++){
        const time = i*beat + Phaser.Math.Between(-120, 120);
        lane = (lane + Phaser.Math.Between(1,3)) % 4;
        schedule.push({ time: Math.max(0, time), lane });
      }
      return schedule;
    }

    function destroyGame(){
      if (gameInstance) {
        gameInstance.destroy(true);
        gameInstance = null;
      }
    }

    function handleAudioError(message){
      statusEl.textContent = message;
      startBtn.disabled = false;
      destroyGame();
    }

    function initGameFromAudio(){
      const durationMs = (Number.isFinite(activeAudio.duration) && activeAudio.duration > 0)
        ? activeAudio.duration * 1000
        : 30000;
      rhythmData.schedule = buildSchedule(durationMs);
      destroyGame();
      gameInstance = new Phaser.Game({
        type: Phaser.AUTO,
        width: 540,
        height: 640,
        parent: 'game-container',
        backgroundColor: '#050912',
        physics: { default: 'arcade' },
        scene: [RhythmScene]
      });
      activeAudio.currentTime = 0;
      activeAudio.play().catch(()=>{
        handleAudioError('ì˜¤ë””ì˜¤ ì¬ìƒì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. ì†Œë¦¬ë¥¼ ì¼œì£¼ì„¸ìš”.');
      });
    }

    function finishRun(scene){
      if (rhythmData.finished) return;
      rhythmData.finished = true;
      const perfect = rhythmData.hits > 0 && rhythmData.misses === 0;
      statusEl.textContent = perfect ? 'ì™„ë²½ í´ë¦¬ì–´! ì‚°íƒ€ ì¡°ê° 5ê°œ íšë“!' : 'í´ë¦¬ì–´! ë‹¤ì‹œ ë„ì „í•´ ë³´ì„¸ìš”.';
      if (perfect && !rhythmData.sent) {
        try { window.parent.postMessage({ type:'christmas-clear', pieces:5, perfect:true }, '*'); } catch {}
        rhythmData.sent = true;
      }
      startBtn.disabled = false;
    }

    class RhythmScene extends Phaser.Scene {
      constructor(){ super('RhythmScene'); }
      create(){
        currentScene = this;
        this.cameras.main.setBackgroundColor('#050912');
        this.hitY = 540;
        this.noteSpeed = 320;
        this.window = 72;
        this.activeNotes = [];
        this.scheduleIndex = 0;
        rhythmData.hits = 0; rhythmData.misses = 0; rhythmData.combo = 0; rhythmData.finished = false; rhythmData.sent = false;
        updateStats();

        const width = this.game.config.width;
        const laneWidth = 120;
        this.laneX = [width/2 - laneWidth*1.5, width/2 - laneWidth*0.5, width/2 + laneWidth*0.5, width/2 + laneWidth*1.5];
        this.add.rectangle(width/2, this.hitY, width, 4, 0xffffff, 0.3);
        this.laneX.forEach((x, idx)=>{
          this.add.rectangle(x, this.hitY, laneWidth-4, 18, Phaser.Display.Color.HexStringToColor(laneColors[idx]).color, 0.18);
        });

        this.input.keyboard.on('keydown', (ev)=>this.handleKey(ev.code));
        rhythmData.startedAt = performance.now();
      }

      spawnNote(lane){
        const x = this.laneX[lane];
        const note = this.add.rectangle(x, -30, 68, 16, Phaser.Display.Color.HexStringToColor(laneColors[lane]).color).setOrigin(0.5);
        note.lane = lane;
        this.activeNotes.push(note);
      }

      handleKey(code){
        const lane = keyToLane[code];
        if (lane === undefined) return;
        let best = null;
        let bestIdx = -1;
        for (let i=0;i<this.activeNotes.length;i++){
          const n = this.activeNotes[i];
          if (n.lane !== lane) continue;
          const dist = Math.abs(n.y - this.hitY);
          if (dist <= this.window && (best === null || dist < best.dist)) {
            best = { note:n, dist, idx:i };
          }
        }
        if (best){
          rhythmData.hits += 1;
          rhythmData.combo = rhythmData.combo + 1;
          best.note.destroy();
          this.activeNotes.splice(best.idx, 1);
          statusEl.textContent = best.dist < 28 ? 'PERFECT!' : 'GOOD!';
        } else {
          rhythmData.misses += 1;
          rhythmData.combo = 0;
          statusEl.textContent = 'MISS...';
        }
        updateStats();
      }

      update(_, delta){
        if (!rhythmData.startedAt || rhythmData.finished) return;
        const now = performance.now();
        const elapsed = now - rhythmData.startedAt;
        while (this.scheduleIndex < rhythmData.schedule.length && rhythmData.schedule[this.scheduleIndex].time <= elapsed + 1100){
          this.spawnNote(rhythmData.schedule[this.scheduleIndex].lane);
          this.scheduleIndex++;
        }

        for (let i=this.activeNotes.length-1;i>=0;i--){
          const n = this.activeNotes[i];
          n.y += this.noteSpeed * (delta/1000);
          if (n.y > this.hitY + this.window){
            rhythmData.misses += 1;
            rhythmData.combo = 0;
            statusEl.textContent = 'MISS...';
            n.destroy();
            this.activeNotes.splice(i,1);
            updateStats();
          }
        }

        if (this.scheduleIndex >= rhythmData.schedule.length && this.activeNotes.length === 0) {
          finishRun(this);
        }
      }
    }

    function audioBufferToWav(buffer){
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const format = 1;
      const bitDepth = 16;
      const bytesPerSample = bitDepth / 8;
      const samples = buffer.length * numChannels;
      const dataLength = samples * bytesPerSample;
      const bufferLength = 44 + dataLength;
      const arrayBuffer = new ArrayBuffer(bufferLength);
      const view = new DataView(arrayBuffer);
      let offset = 0;

      function writeString(str){
        for (let i = 0; i < str.length; i++) {
          view.setUint8(offset++, str.charCodeAt(i));
        }
      }

      function writeUint16(data){ view.setUint16(offset, data, true); offset += 2; }
      function writeUint32(data){ view.setUint32(offset, data, true); offset += 4; }

      writeString('RIFF');
      writeUint32(36 + dataLength);
      writeString('WAVE');
      writeString('fmt ');
      writeUint32(16);
      writeUint16(format);
      writeUint16(numChannels);
      writeUint32(sampleRate);
      writeUint32(sampleRate * numChannels * bytesPerSample);
      writeUint16(numChannels * bytesPerSample);
      writeUint16(bitDepth);
      writeString('data');
      writeUint32(dataLength);

      const channelData = [];
      for (let i = 0; i < numChannels; i++) {
        channelData.push(buffer.getChannelData(i));
      }

      for (let i = 0; i < buffer.length; i++) {
        for (let channel = 0; channel < numChannels; channel++) {
          let sample = channelData[channel][i];
          sample = Math.max(-1, Math.min(1, sample));
          view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7fff, true);
          offset += 2;
        }
      }

      return new Blob([arrayBuffer], { type: 'audio/wav' });
    }

    async function renderTrack(seed){
      const duration = 26;
      const sampleRate = 44100;
      const ctx = new OfflineAudioContext(1, sampleRate * duration, sampleRate);
      const mainGain = ctx.createGain();
      mainGain.gain.value = 0.45;
      mainGain.connect(ctx.destination);

      const baseNotes = [0, 2, 4, 5, 7, 9, 11];
      const tempo = 96 + (seed % 4) * 6;
      const beatTime = 60 / tempo;
      const melodyGain = ctx.createGain();
      melodyGain.gain.value = 0.5;
      melodyGain.connect(mainGain);

      const pad = ctx.createOscillator();
      pad.type = 'triangle';
      pad.frequency.value = 180 + seed * 7;
      const padGain = ctx.createGain();
      padGain.gain.setValueAtTime(0.06, 0);
      pad.connect(padGain).connect(mainGain);
      pad.start(0);
      pad.stop(duration);

      for (let bar = 0; bar < 16; bar++) {
        for (let step = 0; step < 4; step++) {
          const time = (bar * 4 + step) * beatTime;
          const osc = ctx.createOscillator();
          osc.type = 'sine';
          const noteIndex = (seed * 13 + bar * 3 + step * 5) % baseNotes.length;
          const semitone = baseNotes[noteIndex] + 12 * ((bar % 4 === 0) ? 4 : 3);
          const freq = 261.63 * Math.pow(2, semitone / 12);
          osc.frequency.value = freq;
          const g = ctx.createGain();
          const vel = 0.32 + ((bar + step + seed) % 3) * 0.1;
          g.gain.setValueAtTime(0, time);
          g.gain.linearRampToValueAtTime(vel, time + 0.02);
          g.gain.exponentialRampToValueAtTime(0.001, time + beatTime * 0.85);
          osc.connect(g).connect(melodyGain);
          osc.start(time);
          osc.stop(time + beatTime);
        }
      }

      for (let bar = 0; bar < 16; bar++) {
        const time = bar * 4 * beatTime;
        const noise = ctx.createBufferSource();
        const length = Math.floor(sampleRate * 0.12);
        const noiseBuffer = ctx.createBuffer(1, length, sampleRate);
        const data = noiseBuffer.getChannelData(0);
        for (let i = 0; i < length; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.35;
        }
        noise.buffer = noiseBuffer;
        const ng = ctx.createGain();
        ng.gain.setValueAtTime(0.08, time);
        ng.gain.exponentialRampToValueAtTime(0.0001, time + 0.35);
        noise.connect(ng).connect(mainGain);
        noise.start(time);
        noise.stop(time + 0.5);
      }

      return ctx.startRendering();
    }

    async function getTrackUrl(idx){
      if (generatedUrls.has(idx)) return generatedUrls.get(idx);
      try {
        const buffer = await renderTrack(idx + 1);
        const blob = audioBufferToWav(buffer);
        const url = URL.createObjectURL(blob);
        generatedUrls.set(idx, url);
        return url;
      } catch (err) {
        console.error(err);
        throw new Error('íŠ¸ë™ ìƒì„± ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
      }
    }

    async function startGame(){
      const idx = Number(selectEl.value) || 0;
      statusEl.textContent = 'ë¡œë”© ì¤‘...';
      startBtn.disabled = true;
      if (activeAudio) { try { activeAudio.pause(); } catch{} }
      destroyGame();

      try {
        const url = await getTrackUrl(idx);
        activeAudio = new Audio(url);
        activeAudio.crossOrigin = 'anonymous';
      } catch (err) {
        handleAudioError(err.message || 'íŠ¸ë™ì„ ì¤€ë¹„í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
        return;
      }

      const loadTimeout = setTimeout(() => {
        handleAudioError('ìŒì› ë¡œë”©ì´ ì§€ì—°ë©ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
      }, 7000);

      const readyHandler = () => {
        clearTimeout(loadTimeout);
        initGameFromAudio();
      };

      activeAudio.addEventListener('loadedmetadata', readyHandler, { once:true });
      activeAudio.addEventListener('canplaythrough', readyHandler, { once:true });
      activeAudio.addEventListener('error', () => {
        clearTimeout(loadTimeout);
        handleAudioError('ìŒì› ë¡œë”©ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.');
      }, { once:true });
      activeAudio.addEventListener('ended', () => finishRun(currentScene));
      activeAudio.load();
    }

    startBtn.addEventListener('click', () => {
      startGame().catch((err) => handleAudioError(err.message || 'íŠ¸ë™ì„ ì¤€ë¹„í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.'));
    });
    fillTracks();
    statusEl.textContent = 'D / F / J / K í‚¤ë¡œ íŒì •ì„ ì— ë§ì¶° ëˆ„ë¥´ì„¸ìš”.';
  </script>
</body>
</html>
