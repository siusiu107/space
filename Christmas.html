<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>í¬ë¦¬ìŠ¤ë§ˆìŠ¤ í”¼ì•„ë…¸ ë¦¬ë“¬ê²Œì„ ğŸ„ + ì‚°íƒ€ ì¡°ê°</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Noto Sans KR", sans-serif;
      background: radial-gradient(circle at top, #fffbf0 0, #f97373 40%, #111827 100%);
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    .game-wrapper {
      width: min(520px, 100vw);
      padding: 16px;
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.95);
      box-shadow: 0 15px 40px rgba(0,0,0,0.5);
      position: relative;
      overflow: hidden;
    }
    .title {
      text-align: center;
      margin-bottom: 6px;
      font-size: 1.3rem;
      font-weight: 700;
    }
    .subtitle {
      text-align: center;
      font-size: 0.8rem;
      color: #e5e7eb;
      margin-bottom: 4px;
    }
    .reward-info {
      text-align: center;
      font-size: 0.8rem;
      color: #ffe29f;
      margin-bottom: 4px;
    }
    .snowflake {
      position: absolute;
      top: -10px;
      font-size: 12px;
      opacity: 0.6;
      pointer-events: none;
      animation: snow 8s linear infinite;
    }
    @keyframes snow {
      to {
        transform: translateY(110vh);
        opacity: 0;
      }
    }
    .top-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.78rem;
      margin-bottom: 6px;
      gap: 6px;
    }
    .stats span { margin-right: 6px; }
    .hit-feedback {
      text-align: right;
      min-height: 1rem;
      font-weight: 700;
      font-size: 0.8rem;
    }
    .hit-perfect { color: #22c55e; }
    .hit-good    { color: #38bdf8; }
    .hit-miss    { color: #f97373; }

    .song-select {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .song-select label {
      font-size: 0.75rem;
      opacity: 0.9;
    }
    select {
      font-size: 0.8rem;
      padding: 3px 6px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.9);
      background: rgba(15,23,42,0.9);
      color: #e5e7eb;
    }

    .playfield {
      position: relative;
      width: 100%;
      height: 420px;
      border-radius: 12px;
      overflow: hidden;
      background: linear-gradient(to bottom, rgba(15,23,42,0.95), rgba(15,23,42,0.4));
      border: 1px solid rgba(148, 163, 184, 0.4);
      touch-action: none;
    }
    .lanes {
      position: absolute;
      inset: 0;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2px;
    }
    .lane {
      position: relative;
      border-left: 1px solid rgba(148, 163, 184, 0.2);
      border-right: 1px solid rgba(15, 23, 42, 0.9);
      background: linear-gradient(to bottom, rgba(148, 163, 184, 0.08), rgba(15, 23, 42, 0.7));
      touch-action: none;
    }
    .lane:last-child {
      border-right: 1px solid rgba(148, 163, 184, 0.2);
    }
    .hit-line {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 90px;
      height: 4px;
      background: linear-gradient(to right, #facc15, #22c55e, #f97316);
      box-shadow: 0 0 12px rgba(250, 204, 21, 0.9);
    }
    .key-hints {
      position: absolute;
      bottom: 20px;
      left: 0;
      right: 0;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      text-align: center;
      font-weight: 700;
      font-size: 0.9rem;
      color: #e5e7eb;
    }
    .key-hints span {
      padding: 9px 0;
      margin: 0 2px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.9);
      box-shadow: 0 0 8px rgba(148, 163, 184, 0.6);
      user-select: none;
      touch-action: none;
    }
    .key-active {
      background: rgba(34, 197, 94, 0.9) !important;
      border-color: #bbf7d0 !important;
      box-shadow: 0 0 14px rgba(34, 197, 94, 1) !important;
      color: #022c22 !important;
    }

    .note {
      position: absolute;
      left: 10%;
      right: 10%;
      height: 20px;
      border-radius: 999px;
      background: linear-gradient(to right, #f97373, #fb923c, #22c55e);
      box-shadow: 0 0 10px rgba(251, 146, 60, 0.9);
    }

    .control-bar {
      margin-top: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.78rem;
      gap: 6px;
      flex-wrap: wrap;
    }
    .btn-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    button {
      padding: 7px 14px;
      border-radius: 999px;
      border: none;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(to right, #22c55e, #0ea5e9);
      color: #022c22;
      box-shadow: 0 10px 20px rgba(15, 23, 42, 0.7);
      transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s ease;
      white-space: nowrap;
    }
    button:hover { transform: translateY(-1px); filter: brightness(1.05); }
    button:active { transform: translateY(1px); box-shadow: 0 4px 10px rgba(15, 23, 42, 0.7); }
    .btn-demo {
      background: linear-gradient(to right, #9ca3af, #6b7280);
      color: #f9fafb;
    }
    .hint-text {
      text-align: right;
      opacity: 0.8;
      flex: 1;
      min-width: 130px;
    }
    .mobile-hint {
      margin-top: 4px;
      font-size: 0.72rem;
      text-align: center;
      opacity: 0.8;
    }

    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 1rem;
      padding: 16px;
    }
    .overlay h2 {
      margin-bottom: 8px;
      font-size: 1.3rem;
    }
    .overlay p { margin-bottom: 8px; font-size: 0.9rem; white-space: pre-line; }
  </style>
</head>
<body>
  <div class="game-wrapper">
    <div id="snow-container"></div>

    <div class="title">ğŸ„ í¬ë¦¬ìŠ¤ë§ˆìŠ¤ í”¼ì•„ë…¸ ë¦¬ë“¬ê²Œì„ ğŸ¹</div>
    <div class="subtitle">ê³¡ ì„ íƒ â†’ D/F/J/K ë˜ëŠ” ë¼ì¸ í„°ì¹˜ë¡œ ë…¸íŠ¸ë¥¼ ë§ì¶°ë´!</div>
    <div class="reward-info" id="rewardInfo">ì´ ê³¡ í´ë¦¬ì–´ ì‹œ ì‚°íƒ€ ì¡°ê°: 1ê°œ</div>

    <div class="top-row">
      <div class="stats">
        <span>ì ìˆ˜: <span id="score">0</span></span>
        <span>ì½¤ë³´: <span id="combo">0</span></span>
        <span>Max: <span id="maxCombo">0</span></span>
      </div>
      <div class="song-select">
        <label for="songSelect">ê³¡ / ë‚œì´ë„</label>
        <select id="songSelect"></select>
      </div>
    </div>
    <div class="hit-feedback" id="hitFeedback"></div>

    <div class="playfield" id="playfield">
      <div class="lanes" id="lanes">
        <div class="lane" data-lane="0"></div>
        <div class="lane" data-lane="1"></div>
        <div class="lane" data-lane="2"></div>
        <div class="lane" data-lane="3"></div>
      </div>
      <div class="hit-line"></div>
      <div class="key-hints" id="keyHints">
        <span data-key="d">D</span>
        <span data-key="f">F</span>
        <span data-key="j">J</span>
        <span data-key="k">K</span>
      </div>
    </div>

    <div class="control-bar">
      <div class="btn-row">
        <button id="startBtn" type="button">ê²Œì„ ì‹œì‘</button>
        <button id="demoBtn" class="btn-demo" type="button">ëª¨ë²” ì—°ì£¼ ë³´ê¸°</button>
      </div>
      <div class="hint-text">
        ì„  ìœ„ 80px / ì•„ë˜ 45px ì•ˆì´ë©´ ì„±ê³µ<br>
        ì•½ê°„ ë¹—ë‚˜ê°„ ê±´ 2ë²ˆê¹Œì§€ ë´ì¤Œ
      </div>
    </div>
    <div class="mobile-hint">
      ğŸ“± ëª¨ë°”ì¼: ê° ë¼ì¸ ë˜ëŠ” ì•„ë˜ D/F/J/K ë²„íŠ¼ì„ í†¡ ëˆ„ë¥´ë©´ ë¼.
    </div>

    <div class="overlay" id="overlay" style="display:none;">
      <h2 id="overlayTitle">ê²Œì„ ì˜¤ë²„</h2>
      <p id="overlayText"></p>
      <button id="retryBtn" type="button">ë‹¤ì‹œ í•˜ê¸°</button>
    </div>
  </div>

  <script>
    const laneKeys = ["d", "f", "j", "k"];
    const NOTE_HEIGHT = 20;
    const fallTime = 1.0;
    const NEAR_MISS_TIME_WINDOW = 0.18;

    // Extreme ì´ìƒ ë‚œì´ë„ ID
    const HIGH_DIFF_IDS = new Set(["ultra", "legend"]);

    let score = 0, combo = 0, maxCombo = 0;
    let isPlaying = false;
    let isDemoMode = false;
    let startTime = 0;
    let chartNotes = [];
    let activeNotes = [];
    let animationId = null;
    let audioCtx = null;
    let songLengthSec = 0;
    let currentSong = null;
    let softMissCount = 0;
    let demoTimers = [];

    const scoreEl = document.getElementById("score");
    const comboEl = document.getElementById("combo");
    const maxComboEl = document.getElementById("maxCombo");
    const feedbackEl = document.getElementById("hitFeedback");
    const playfield = document.getElementById("playfield");
    const lanesEl = document.getElementById("lanes");
    const startBtn = document.getElementById("startBtn");
    const demoBtn = document.getElementById("demoBtn");
    const overlay = document.getElementById("overlay");
    const overlayTitle = document.getElementById("overlayTitle");
    const overlayText = document.getElementById("overlayText");
    const retryBtn = document.getElementById("retryBtn");
    const songSelectEl = document.getElementById("songSelect");
    const keyHintEls = document.querySelectorAll(".key-hints span");
    const hitLineEl = document.querySelector(".hit-line");
    const rewardInfoEl = document.getElementById("rewardInfo");
    const docEl = document.documentElement;

    const isMobile = /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent);

    // ëˆˆ íš¨ê³¼
    const snowContainer = document.getElementById("snow-container");
    function createSnowflake() {
      const snow = document.createElement("div");
      snow.className = "snowflake";
      snow.textContent = "â„";
      snow.style.left = Math.random() * 100 + "%";
      snow.style.opacity = (0.5 + Math.random() * 0.5).toFixed(2);
      snow.style.fontSize = (8 + Math.random() * 10) + "px";
      snow.style.animationDuration = (6 + Math.random() * 6) + "s";
      snowContainer.appendChild(snow);
      setTimeout(() => snow.remove(), 13000);
    }
    setInterval(createSnowflake, 500);

    // ê³¡ ì •ì˜
    const LANE_TO_PITCH = ["C5", "D5", "E5", "G5"];

    function makeSong(id, title, difficulty, bpm, measures, patternFn) {
      const notes = [];
      for (let m = 0; m < measures; m++) {
        const baseBeat = m * 4;
        patternFn(notes, baseBeat, m, bpm);
      }
      return { id, title, difficulty, bpm, leadInBeats: 4, notes };
    }

    const SONGS = (() => {
      const songs = [];

      // Easy
      songs.push(makeSong(
        "easy",
        "Snowy Steps",
        "Easy",
        120,
        16,
        (notes, beat, measure, bpm) => {
          if (measure >= 12) {
            const offsets = [0, 0.5, 1.5, 2, 3];
            offsets.forEach((off, idx) => {
              const lane = (measure * 2 + idx * 3) % 4;
              notes.push({
                beat: beat + off,
                lane,
                pitch: LANE_TO_PITCH[lane],
                durBeats: 0.5,
                type: "tap"
              });
            });
            return;
          }
          for (let s = 0; s < 4; s++) {
            const lane = s;
            notes.push({
              beat: beat + s,
              lane,
              pitch: LANE_TO_PITCH[lane],
              durBeats: 1,
              type: "tap"
            });
          }
        }
      ));

      // Normal
      songs.push(makeSong(
        "normal",
        "Jingle Path",
        "Normal",
        135,
        16,
        (notes, beat, measure, bpm) => {
          if (measure >= 12) {
            const offsets = [0, 0.5, 1.5, 2, 2.5, 3, 3.5];
            offsets.forEach((off, idx) => {
              const lane = (measure + idx * 2) % 4;
              notes.push({
                beat: beat + off,
                lane,
                pitch: LANE_TO_PITCH[lane],
                durBeats: 0.5,
                type: "tap"
              });
            });
            return;
          }
          const offsets = [0, 1.5, 2, 3.5];
          offsets.forEach((off, idx) => {
            const lane = (measure + idx) % 4;
            notes.push({
              beat: beat + off,
              lane,
              pitch: LANE_TO_PITCH[lane],
              durBeats: 0.5,
              type: "tap"
            });
          });
        }
      ));

      // Hard
      songs.push(makeSong(
        "hard",
        "Carol Rush",
        "Hard",
        150,
        16,
        (notes, beat, measure, bpm) => {
          if (measure >= 12) {
            const offsets = [0, 0.25, 0.75, 1.0, 1.75, 2.0, 2.5, 3.0, 3.25];
            offsets.forEach((off, idx) => {
              const lane = (measure * 3 + idx * 5) % 4;
              notes.push({
                beat: beat + off,
                lane,
                pitch: LANE_TO_PITCH[lane],
                durBeats: 0.5,
                type: "tap"
              });
            });
            return;
          }
          const offsets = [0, 0.5, 1, 2, 2.5, 3];
          offsets.forEach((off, idx) => {
            const lane = (measure + idx) % 4;
            notes.push({
              beat: beat + off,
              lane,
              pitch: LANE_TO_PITCH[lane],
              durBeats: 0.5,
              type: "tap"
            });
          });
        }
      ));

      // Expert
      songs.push(makeSong(
        "expert",
        "Starry Night Ride",
        "Expert",
        165,
        16,
        (notes, beat, measure, bpm) => {
          if (measure >= 12) {
            const baseLane = measure % 4;
            const laneA = baseLane;
            const laneB = (baseLane + 1) % 4;
            const pattern = [
              { off: 0.0, lane: laneA },
              { off: 0.5, lane: laneB },
              { off: 1.0, lane: laneA },
              { off: 1.5, lane: laneB },
              { off: 2.5, lane: laneA },
              { off: 3.0, lane: laneB }
            ];
            pattern.forEach(p => {
              notes.push({
                beat: beat + p.off,
                lane: p.lane,
                pitch: LANE_TO_PITCH[p.lane],
                durBeats: 0.5,
                type: "tap"
              });
            });
            return;
          }

          const baseLane = measure % 4;
          notes.push({ beat: beat + 0,   lane: baseLane,            pitch: LANE_TO_PITCH[baseLane],            durBeats: 0.5, type: "tap" });
          notes.push({ beat: beat + 0.5, lane: (baseLane+1)%4,      pitch: LANE_TO_PITCH[(baseLane+1)%4],      durBeats: 0.5, type: "tap" });
          notes.push({ beat: beat + 1,   lane: (baseLane+2)%4,      pitch: LANE_TO_PITCH[(baseLane+2)%4],      durBeats: 0.5, type: "tap" });
          notes.push({ beat: beat + 1.5, lane: (baseLane+3)%4,      pitch: LANE_TO_PITCH[(baseLane+3)%4],      durBeats: 0.5, type: "tap" });
          notes.push({ beat: beat + 2,   lane: baseLane,            pitch: LANE_TO_PITCH[baseLane],            durBeats: 0.5, type: "tap" });
          notes.push({ beat: beat + 2,   lane: (baseLane+2)%4,      pitch: LANE_TO_PITCH[(baseLane+2)%4],      durBeats: 0.5, type: "tap" });
        }
      ));

      // Extreme (ì¡°ê¸ˆ ë” ì¸ê°„ì ì¸ íŒ¨í„´)
      songs.push(makeSong(
        "extreme",
        "Santa Storm",
        "Extreme",
        175,
        16,
        (notes, beat, measure, bpm) => {
          const laneA = measure % 4;
          const laneB = (measure + 1) % 4;

          if (measure >= 12) {
            // ë‘ ë¼ì¸ ìœ„ì£¼ 8ë¹„íŠ¸ ëŸ¬ì‰¬ (ì‚´ì§ë§Œ ë¹¡ì„¼ êµ¬ê°„)
            const pattern = [
              { off: 0.0, lane: laneA },
              { off: 0.5, lane: laneB },
              { off: 1.0, lane: laneA },
              { off: 1.5, lane: laneB },
              { off: 2.0, lane: laneA },
              { off: 2.5, lane: laneB },
              { off: 3.0, lane: laneA },
              { off: 3.5, lane: laneB }
            ];
            pattern.forEach(p => {
              notes.push({
                beat: beat + p.off,
                lane: p.lane,
                pitch: LANE_TO_PITCH[p.lane],
                durBeats: 0.5,
                type: "tap"
              });
            });
            return;
          }

          // ì•/ì¤‘ë°˜: 8ë¶„ + ê°€ë” 16ë¶„, ì†ê¼¬ì„ ì¤„ì¸ íŒ¨í„´
          const pattern = [
            { off: 0.0,  lane: laneA },
            { off: 0.5,  lane: laneA },
            { off: 1.0,  lane: laneB },
            { off: 1.5,  lane: laneB },
            { off: 2.25, lane: laneA },
            { off: 2.75, lane: laneB }
          ];
          pattern.forEach(p => {
            notes.push({
              beat: beat + p.off,
              lane: p.lane,
              pitch: LANE_TO_PITCH[p.lane],
              durBeats: 0.5,
              type: "tap"
            });
          });
        }
      ));

      // Ultra (ê¸°ì¡´ Extreme íŒ¨í„´ ê·¸ëŒ€ë¡œ)
      songs.push(makeSong(
        "ultra",
        "Santa Storm+",
        "Ultra",
        180,
        16,
        (notes, beat, measure, bpm) => {
          const laneA = measure % 4;
          const laneB = (measure + 1) % 4;
          const laneC = (measure + 2) % 4;

          if (measure >= 12) {
            const pattern = [
              { off: 0.00, lanes: [laneA, laneC] },
              { off: 0.25, lanes: [laneB] },
              { off: 0.50, lanes: [laneA] },
              { off: 0.75, lanes: [laneB] },

              { off: 1.00, lanes: [laneC, laneA] },
              { off: 1.25, lanes: [laneB] },
              { off: 1.50, lanes: [laneA] },
              { off: 1.75, lanes: [laneC] },

              { off: 2.00, lanes: [laneB, laneA] },
              { off: 2.25, lanes: [laneC] },
              { off: 2.50, lanes: [laneB] },
              { off: 2.75, lanes: [laneA] },

              { off: 3.00, lanes: [laneC, laneB] },
              { off: 3.25, lanes: [laneA] }
            ];
            pattern.forEach(p => {
              p.lanes.forEach(L => {
                notes.push({
                  beat: beat + p.off,
                  lane: L,
                  pitch: LANE_TO_PITCH[L],
                  durBeats: 0.5,
                  type: "tap"
                });
              });
            });
            return;
          }

          const pattern = [
            { off: 0.00, lanes: [laneA] },
            { off: 0.50, lanes: [laneB] },
            { off: 0.75, lanes: [laneC] },
            { off: 1.00, lanes: [laneA, laneB] },
            { off: 1.50, lanes: [laneC] },
            { off: 2.00, lanes: [laneB] },
            { off: 2.25, lanes: [laneA] },
            { off: 2.50, lanes: [laneC, laneA] },
            { off: 3.00, lanes: [laneB] }
          ];
          pattern.forEach(p => {
            p.lanes.forEach(L => {
              notes.push({
                beat: beat + p.off,
                lane: L,
                pitch: LANE_TO_PITCH[L],
                durBeats: 0.5,
                type: "tap"
              });
            });
          });
        }
      ));

      // Legend (Ultraë³´ë‹¤ ë” ë¯¸ì¹œ íŒ¨í„´)
      songs.push(makeSong(
        "legend",
        "Santa Storm++",
        "Legend",
        190,
        16,
        (notes, beat, measure, bpm) => {
          const laneA = measure % 4;
          const laneB = (measure + 1) % 4;
          const laneC = (measure + 2) % 4;
          const laneD = (measure + 3) % 4;

          const pattern = [
            { off: 0.00, lanes: [laneA] },
            { off: 0.25, lanes: [laneB] },
            { off: 0.50, lanes: [laneC] },
            { off: 0.75, lanes: [laneD] },

            { off: 1.00, lanes: [laneA, laneC] },
            { off: 1.25, lanes: [laneB] },
            { off: 1.50, lanes: [laneD] },
            { off: 1.75, lanes: [laneC] },

            { off: 2.00, lanes: [laneB, laneD] },
            { off: 2.25, lanes: [laneA] },
            { off: 2.50, lanes: [laneC] },
            { off: 2.75, lanes: [laneB] },

            { off: 3.00, lanes: [laneA, laneD] },
            { off: 3.25, lanes: [laneC] }
          ];

          // ë§ˆì§€ë§‰ 4ë§ˆë””ëŠ” ê°™ì€ íŒ¨í„´ ë°˜ë³µ (ì •ì‹ ì—†ì§€ë§Œ ê·œì¹™ì )
          pattern.forEach(p => {
            p.lanes.forEach(L => {
              notes.push({
                beat: beat + p.off,
                lane: L,
                pitch: LANE_TO_PITCH[L],
                durBeats: 0.5,
                type: "tap"
              });
            });
          });
        }
      ));

      return songs;
    })();

    // ë‚œì´ë„ë³„ ì‚°íƒ€ ì¡°ê° ê°œìˆ˜
    const DIFFICULTY_PIECES = {
      easy: 1,
      normal: 2,
      hard: 3,
      expert: 10,
      extreme: 20,
      ultra: 100,
      legend: 300
    };

    function getPiecesForSong(song) {
      if (!song) return 1;
      return DIFFICULTY_PIECES[song.id] ?? 1;
    }

    function updateRewardInfo() {
      if (!rewardInfoEl) return;
      const pieces = getPiecesForSong(currentSong);
      rewardInfoEl.textContent = `ì´ ê³¡ í´ë¦¬ì–´ ì‹œ ì‚°íƒ€ ì¡°ê°: ${pieces}ê°œ`;
    }

    function sendSantaPieces(pieces) {
      const payload = { type: 'christmas-clear', pieces };
      try { window.parent?.postMessage(payload, '*'); } catch (e) {}
    }

    function requestFullscreenIfNeeded() {
      if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
        return;
      }

      const request = docEl.requestFullscreen || docEl.webkitRequestFullscreen || docEl.msRequestFullscreen;
      try {
        request?.call(docEl);
      } catch (e) {
        console.warn('ì „ì²´í™”ë©´ ìš”ì²­ ì‹¤íŒ¨', e);
      }
    }

    // ê³¡ ì„ íƒ UI
    SONGS.forEach(song => {
      const opt = document.createElement("option");
      opt.value = song.id;
      opt.textContent = `${song.title} (${song.difficulty})`;
      songSelectEl.appendChild(opt);
    });
    currentSong = SONGS[0];
    updateRewardInfo();

    songSelectEl.addEventListener("change", () => {
      currentSong = SONGS.find(s => s.id === songSelectEl.value) || SONGS[0];
      updateRewardInfo();
    });

    // ì˜¤ë””ì˜¤
    function noteToFreq(note) {
      const A4 = 440;
      const map = {
        "C4": -9, "D4": -7, "E4": -5, "F4": -4, "G4": -2, "A4": 0, "B4": 2,
        "C5": 3,  "D5": 5,  "E5": 7,  "F5": 8,  "G5": 10, "A5": 12
      };
      const semi = map[note] ?? 0;
      return A4 * Math.pow(2, semi / 12);
    }

    function playSongAudio(song) {
      if (audioCtx) {
        try { audioCtx.close(); } catch (e) {}
        audioCtx = null;
      }
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      const beatDur = 60 / song.bpm;
      const lead = song.leadInBeats * beatDur;
      const now = audioCtx.currentTime;
      const startAt = now + 0.2;

      song.notes.forEach(n => {
        const start = startAt + lead + n.beat * beatDur;
        const dur = n.durBeats * beatDur;

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = "square";
        osc.frequency.value = noteToFreq(n.pitch);

        const g = gain.gain;
        g.setValueAtTime(0, start);
        g.linearRampToValueAtTime(0.3, start + 0.02);
        g.linearRampToValueAtTime(0.25, start + dur * 0.7);
        g.linearRampToValueAtTime(0.0, start + dur);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(start);
        osc.stop(start + dur + 0.05);
      });

      songLengthSec = (song.leadInBeats + (song.notes.reduce((max, n) =>
        Math.max(max, n.beat + n.durBeats), 0))) * beatDur + 0.3;
    }

    // ì°¨íŠ¸ ë³€í™˜
    function buildChartFromSong(song) {
      const beatDur = 60 / song.bpm;
      const lead = song.leadInBeats * beatDur;
      const arr = [];

      song.notes.forEach(n => {
        const startTime = lead + n.beat * beatDur;
        const endTime = startTime + n.durBeats * beatDur;
        arr.push({
          lane: n.lane,
          type: "tap",
          pitch: n.pitch,
          startTime,
          endTime,
          spawnTime: startTime - fallTime,
          hitTime: startTime,
          spawned: false,
          hit: false,
          missed: false
        });
      });

      const last = arr.reduce((max, n) => Math.max(max, n.endTime), 0);
      songLengthSec = last + 0.5;
      return arr;
    }

    // Demo íƒ€ì´ë¨¸
    function clearDemoTimers() {
      demoTimers.forEach(id => clearTimeout(id));
      demoTimers = [];
    }

    function scheduleDemoPresses() {
      clearDemoTimers();
      chartNotes.forEach(n => {
        const delayMs = n.hitTime * 1000;
        const id = setTimeout(() => {
          if (!isPlaying || !isDemoMode) return;
          const key = laneKeys[n.lane];
          flashKey(key);
          // ë°ëª¨ëŠ” ë¬´ì¡°ê±´ Perfect ì²˜ë¦¬
          handlePress(n.lane, { forcePerfect: true });
        }, delayMs);
        demoTimers.push(id);
      });
    }

    // ê²Œì„ ì œì–´
    function resetGame() {
      score = 0; combo = 0; maxCombo = 0;
      softMissCount = 0;
      scoreEl.textContent = 0;
      comboEl.textContent = 0;
      maxComboEl.textContent = 0;
      feedbackEl.textContent = "";
      feedbackEl.className = "hit-feedback";
      activeNotes.forEach(n => n.el.remove());
      activeNotes = [];
      overlay.style.display = "none";
      clearDemoTimers();
    }

    function maybeWarnHighDifficulty(song) {
      if (HIGH_DIFF_IDS.has(song.id)) {
        alert("ê²½ê³ : ì´ ë‚œì´ë„ëŠ” ê¹¨ëŠ” ê²ƒì´ ë¶ˆê°€ëŠ¥í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤ ã…‹ã…‹");
      }
    }

    function startGame() {
      isDemoMode = false;
      currentSong = SONGS.find(s => s.id === songSelectEl.value) || SONGS[0];
      updateRewardInfo();
      maybeWarnHighDifficulty(currentSong);
      requestFullscreenIfNeeded();
      resetGame();
      chartNotes = buildChartFromSong(currentSong);

      if (animationId) cancelAnimationFrame(animationId);
      isPlaying = true;
      startTime = performance.now() / 1000;

      playSongAudio(currentSong);
      animationId = requestAnimationFrame(gameLoop);
    }

    function startDemo() {
      isDemoMode = true;
      currentSong = SONGS.find(s => s.id === songSelectEl.value) || SONGS[0];
      updateRewardInfo();
      maybeWarnHighDifficulty(currentSong);
      resetGame();
      chartNotes = buildChartFromSong(currentSong);

      if (animationId) cancelAnimationFrame(animationId);
      isPlaying = true;
      startTime = performance.now() / 1000;

      playSongAudio(currentSong);
      scheduleDemoPresses();
      animationId = requestAnimationFrame(gameLoop);
    }

    function endGame(reason) {
      if (!isPlaying) return;
      isPlaying = false;
      if (animationId) cancelAnimationFrame(animationId);
      clearDemoTimers();

      if (audioCtx) {
        try { audioCtx.close(); } catch (e) {}
        audioCtx = null;
      }

      let title, text;
      if (reason === "gameover") {
        title = "ê²Œì„ ì˜¤ë²„ ğŸ˜µ";
        text = `${currentSong.title} (${currentSong.difficulty})\nì ìˆ˜: ${score} / Max Combo: ${maxCombo}`;
      } else {
        if (isDemoMode) {
          title = "ëª¨ë²” ì—°ì£¼ ì™„ë£Œ ğŸ¶";
          text = `${currentSong.title} (${currentSong.difficulty})\nì ìˆ˜: ${score} / Max Combo: ${maxCombo}\nì—°ìŠµ ëª¨ë“œì—ì„œëŠ” ì‚°íƒ€ ì¡°ê°ì´ ì§€ê¸‰ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`;
        } else {
          title = "í´ë¦¬ì–´! ğŸ‰";
          const pieces = getPiecesForSong(currentSong);
          sendSantaPieces(pieces);
          text = `${currentSong.title} (${currentSong.difficulty})\nì ìˆ˜: ${score} / Max Combo: ${maxCombo}\nì‚°íƒ€ ì¡°ê° ${pieces}ê°œë¥¼ ë³´ëƒˆì–´ìš”!`;
        }
      }
      overlayTitle.textContent = title;
      overlayText.textContent = text;
      overlay.style.display = "flex";
    }

    startBtn.addEventListener("click", startGame);
    demoBtn.addEventListener("click", startDemo);
    retryBtn.addEventListener("click", () => {
      isDemoMode = false;
      startGame();
    });

    // ë…¸íŠ¸ ìŠ¤í°/ì—…ë°ì´íŠ¸
    function spawnNote(noteObj) {
      const laneEl = lanesEl.children[noteObj.lane];
      const noteEl = document.createElement("div");
      noteEl.className = "note";
      noteEl.style.top = "-24px";
      laneEl.appendChild(noteEl);

      activeNotes.push({
        ...noteObj,
        el: noteEl
      });
    }

    function updateNotes(elapsed) {
      const fieldRect = playfield.getBoundingClientRect();
      const lineRect = hitLineEl.getBoundingClientRect();
      const hitLineY = (lineRect.top - fieldRect.top) + lineRect.height / 2;

      activeNotes.forEach(obj => {
        if (obj.hit || obj.missed) return;

        const dt = elapsed - obj.spawnTime;
        const progress = dt / fallTime;
        const y = progress * hitLineY;
        obj.el.style.top = y + "px";

        if (y > hitLineY + 120 && !obj.hit && !obj.missed) {
          obj.missed = true;
          obj.el.style.opacity = "0.2";
          if (!isDemoMode) {
            addJudgement("miss");
          }
        }
      });

      for (let i = activeNotes.length - 1; i >= 0; i--) {
        const obj = activeNotes[i];
        const top = parseFloat(obj.el.style.top || "0");
        if (top > fieldRect.height + 40 || obj.missed || obj.hit) {
          obj.el.remove();
          activeNotes.splice(i, 1);
        }
      }
    }

    // ì ìˆ˜ & íŒì •
    function addJudgement(type, options) {
      options = options || {};
      const soft = !!options.soft;

      if (isDemoMode && type === "miss") {
        return;
      }

      if (type === "perfect") {
        score += 100;
        combo += 1;
        maxCombo = Math.max(maxCombo, combo);
        feedbackEl.textContent = "Perfect!";
        feedbackEl.className = "hit-feedback hit-perfect";
      } else if (type === "good") {
        score += 60;
        combo += 1;
        maxCombo = Math.max(maxCombo, combo);
        feedbackEl.textContent = "Good!";
        feedbackEl.className = "hit-feedback hit-good";
      } else if (type === "miss") {
        combo = 0;

        if (soft && softMissCount < 2) {
          softMissCount++;
          feedbackEl.textContent = "Almost...";
          feedbackEl.className = "hit-feedback hit-miss";
        } else {
          feedbackEl.textContent = "Miss";
          feedbackEl.className = "hit-feedback hit-miss";
          endGame("gameover");
        }
      }
      scoreEl.textContent = score;
      comboEl.textContent = combo;
      maxComboEl.textContent = maxCombo;
    }

    // ì…ë ¥ ì²˜ë¦¬
    function flashKey(key) {
      key = key.toLowerCase();
      keyHintEls.forEach(el => {
        if (el.dataset.key === key) {
          el.classList.add("key-active");
          setTimeout(() => el.classList.remove("key-active"), 120);
        }
      });
    }

    function handlePress(laneIndex, options = {}) {
      const forcePerfect = !!options.forcePerfect;
      if (!isPlaying) return;

      const now = performance.now() / 1000;
      const elapsed = now - startTime;

      const fieldRect = playfield.getBoundingClientRect();
      const lineRect = hitLineEl.getBoundingClientRect();
      const hitLineY = (lineRect.top - fieldRect.top) + lineRect.height / 2;

      const candidates = activeNotes.filter(
        n => n.lane === laneIndex && !n.hit && !n.missed
      );

      if (candidates.length === 0) {
        if (!forcePerfect) addJudgement("miss");
        return;
      }

      const successMarginAbove = 80;
      const successMarginBelow = 45;

      const overlapped = candidates.filter(n => {
        const top = parseFloat(n.el.style.top || "0");
        const bottom = top + NOTE_HEIGHT;
        return bottom >= (hitLineY - successMarginAbove) &&
               top    <= (hitLineY + successMarginBelow);
      });

      if (overlapped.length === 0) {
        let best = null;
        let bestTimeDiff = Infinity;

        candidates.forEach(n => {
          const diff = Math.abs(n.hitTime - elapsed);
          if (diff < bestTimeDiff) {
            bestTimeDiff = diff;
            best = n;
          }
        });

        if (forcePerfect && best) {
          best.hit = true;
          if (best.el) {
            best.el.style.background = "linear-gradient(to right, #22c55e, #a3e635)";
            best.el.style.boxShadow = "0 0 12px rgba(34,197,94,1)";
          }
          addJudgement("perfect");
        } else {
          if (best && bestTimeDiff <= NEAR_MISS_TIME_WINDOW) {
            best.missed = true;
            if (best.el) best.el.style.opacity = "0.2";
            addJudgement("miss", { soft: true });
          } else {
            addJudgement("miss");
          }
        }
        return;
      }

      let best = null;
      let bestDist = Infinity;
      overlapped.forEach(n => {
        const top = parseFloat(n.el.style.top || "0");
        const center = top + NOTE_HEIGHT / 2;
        const dist = Math.abs(center - hitLineY);
        if (dist < bestDist) {
          bestDist = dist;
          best = n;
        }
      });
      if (!best) return;

      best.hit = true;
      if (forcePerfect) {
        if (best.el) {
          best.el.style.background = "linear-gradient(to right, #22c55e, #a3e635)";
          best.el.style.boxShadow = "0 0 12px rgba(34,197,94,1)";
        }
        addJudgement("perfect");
      } else {
        const top = parseFloat(best.el.style.top || "0");
        const center = top + NOTE_HEIGHT / 2;
        const dist = Math.abs(center - hitLineY);

        if (dist <= 10) {
          best.el.style.background = "linear-gradient(to right, #22c55e, #a3e635)";
          best.el.style.boxShadow = "0 0 12px rgba(34,197,94,1)";
          addJudgement("perfect");
        } else {
          best.el.style.background = "linear-gradient(to right, #38bdf8, #22c55e)";
          best.el.style.boxShadow = "0 0 12px rgba(56,189,248,1)";
          addJudgement("good");
        }
      }
    }

    // í‚¤ë³´ë“œ ì…ë ¥
    window.addEventListener("keydown", (e) => {
      if (!isPlaying) return;
      const key = e.key.toLowerCase();
      const idx = laneKeys.indexOf(key);
      if (idx !== -1) {
        e.preventDefault();
        flashKey(key);
        handlePress(idx);
      }
    });

    // í„°ì¹˜/ë§ˆìš°ìŠ¤ ì…ë ¥ (ë¼ì¸)
    Array.from(lanesEl.children).forEach((laneEl, idx) => {
      laneEl.addEventListener("pointerdown", (e) => {
        if (!isPlaying) return;
        e.preventDefault();
        flashKey(laneKeys[idx]);
        handlePress(idx);
      });
    });

    // í„°ì¹˜/ë§ˆìš°ìŠ¤ ì…ë ¥ (ì•„ë˜ ë²„íŠ¼)
    keyHintEls.forEach((el, idx) => {
      el.addEventListener("pointerdown", (e) => {
        if (!isPlaying) return;
        e.preventDefault();
        flashKey(laneKeys[idx]);
        handlePress(idx);
      });
    });

    // ë©”ì¸ ë£¨í”„
    function gameLoop() {
      if (!isPlaying) return;

      const now = performance.now() / 1000;
      const elapsed = now - startTime;

      chartNotes.forEach(n => {
        if (!n.spawned && elapsed >= n.spawnTime) {
          n.spawned = true;
          spawnNote(n);
        }
      });

      updateNotes(elapsed);

      const allSpawned = chartNotes.every(n => n.spawned);
      if (allSpawned && activeNotes.length === 0 && elapsed > songLengthSec) {
        endGame("clear");
        return;
      }

      animationId = requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>
